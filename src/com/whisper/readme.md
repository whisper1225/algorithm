#  关于时间复杂度的分析
1. 关于冒泡非常好理解在不采用优化的情况下，必然是o(n^2)
2. 对于归并，排序逻辑是不管你什么顺序，我都是拆散，然后两两合并排序，形成大一点的元组，然后这些元组在两两合并排序。
从树形图我们可以看出，要执行logn次合并，每次合并需要进行nc次操作。时间复杂度 稳定在 nlogn
3. 对于快排，这个的基本逻辑是 选取基准数，然后待排序的每个数比较（n），小的放一边 大的放一边。最好情况是每次选取的都是中位数，这样选取基准数，就是logn,如果不行每次选到最大或者最小的那么需要选取n次此时时间复杂度为n^2
4. 从各种算法来说时间复杂度：n个数总共有n!种排序，我们比较k次，获得k个大小关系，k个大小关系总共有2^k种组合方式。因此只有当
2^k>n!才有可能有可能有可能完成排序。因此最小时间复杂度是ologn!
等效于logn


## 快排
 选个基准数 外层循环走完之后,比基准数小的全部到基准左边,反之都到基准的右边.
 这同时意味着如果我们的 基准数如果我们选取了中位数,那么每次外层循环走完之后,基准数左右两边几乎等量的数据. 这种情况下时间复杂度 nlogn
 但是如果选取了最大值或者最小值,这种情况下 实际上他左边或者右边相当于没排,从信息熵的角度来理解,实际上只解决了一个值的我位置


